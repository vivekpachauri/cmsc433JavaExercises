
package cmsc433.p1;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.util.HashMap;

/**
 * This is a servlet decorator that caches all calls to the doGet method of the wrapper servlet. If the path and options
 * are identical to those used in a previous call, it returns the same result as generated by that previous call.
 * Otherwise (e.g., this is the first time the Cache servlet has been invoked with a particular combination of path and
 * options, the cache passes the path and options to the wrapped servlet, caches the result, and then sends the output
 * to the output stream.
 * 
 * <p>
 * If the invocation of the doGet method of the wrapped servlet throws an exception, it is optional as to whether the
 * exception is cached or not.
 */
public class Cache implements Servlet
{

    private final Servlet decorated;
    
    /* local request-response dictionary */
    private HashMap<String, byte[]> dictionary;
    
    public Cache(Servlet decorated)
    {
        this.decorated = decorated;
    }

    /*
     * (non-Javadoc)
     * 
     * @see cmsc433.p1.Servlet#doGet(java.lang.String, java.lang.String,
     * java.io.OutputStream)
     */
    public void doGet(String path, String options, OutputStream out) throws ServletException, ShutdownException
    {
        /* check if this request has previously been handled */
        if ( this.dictionary.containsKey(path) == true ) 
        /* if yes then return the request from the cache */
        {
            try
            {
                out.write(this.dictionary.get(path));
            }
            catch (IOException e)
            {
                e.printStackTrace();
                throw new ServletException("Exception", e, ServletException.HTTP_INTERNAL_SERVER_ERROR);
            }
        }
        /* if no then call the decorated servlet to generated the response, cache it and then return the response */
        else
        {
            /* call the decorated servlet using our own output stream to get the response */
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            
            this.decorated.doGet(path, options, baos);
            /* store the response in local dictionary */
            this.dictionary.put(path, baos.toByteArray());
            /* return the response */
            try
            {
                out.write(baos.toByteArray());
            }
            catch (IOException e)
            {
                e.printStackTrace();
                throw new ServletException("Exception", e, ServletException.HTTP_INTERNAL_SERVER_ERROR);
            }
        }        
    }

}
