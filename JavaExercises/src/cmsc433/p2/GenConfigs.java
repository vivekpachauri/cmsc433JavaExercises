
package cmsc433.p2;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Set;

/**
 * The Class GenConfigs.
 */

public class GenConfigs implements ACDGVisitor
{

    private ACDG acdg;
    private final List<ACDG> configs;

    /**
     * Instantiates a new gen configs.
     * 
     * @param a
     *            the ACDG
     */
    GenConfigs(ACDG a)
    {

        this.acdg = a;
        this.configs = new ArrayList<ACDG>();
    }

    /*
     * (non-Javadoc)
     * 
     * @see cmsc433.p2.ACDGVisitor#visit(cmsc433.p2.ComponentNode)
     */
    public void visit(ComponentNode n)
    {

        /* c'mon i need to figure this out quickly, where am i storing the acdg(s), or how am
        * I generating them while visiting a component node??
        */
        /*
         * so I have the strategy now, we will be partial acdg with every node visit
         */
        /* if possible configs are empty then create a new partial config with just this node
         * and all of the incoming edges
         */
        /* if possible configs are not empty then add this node to the possible configs along with
         * all the incoming edges corresponding to this node in the original acdg
         */

        /* if this node is a branch node then create n copies of all the existing acdg(s)
         * where n is the number of branches generated by this node
         */
        /* if we are visiting a component node then check the versions it has and if there are more than 1 then for every version
         * create a new config (acdg)
         */
        /*
         * I don't think I have any need to handle the top and bottom nodes separately, however the question is how and where do i store the partial
         * acdg(s)
         */
        updateConfigsDueToComponentVersions(n);

    }

    /*
     * (non-Javadoc)
     * 
     * @see cmsc433.p2.ACDGVisitor#visit(cmsc433.p2.RelationAndNode)
     */
    public void visit(RelationAndNode n)
    {

        /* this case is going to be the simplest of all three, 
         * simply iterate over the existing acdg(s) in config 
         * and add this node and its incoming edges to all of them */
        for (ACDG acdg : this.configs)
        {
            acdg.getGraph().addNode(n.clone());
            for (MyEdge edge : this.acdg.getGraph().getOutEdges(n))
            {
                /* can't add the edge object directly, should add a new edge */
                acdg.getGraph().addEdge(new MyEdge(edge.getParent().clone(), edge.getChild().clone()));
            }
        }
        /* and done */
    }

    /*
     * (non-Javadoc)
     * 
     * @see cmsc433.p2.ACDGVisitor#visit(cmsc433.p2.RelationXorNode)
     */
    public void visit(RelationXorNode n)
    {
        /*
         * and we're stuck again, the logic of building acdg(s) partially
         * in the case of component nodes while adding the node and
         * its incoming edges is not going to work in this case because
         * the logic of relation xor node require us to only add
         * one outgoing edge to the to all the acdg while creating new
         * acdg(s) depending on the branching factor determined by the
         * number of outgoing edges of this node.
         */
        /* therefore the logic of adding this node and all of the
         * incoming edges is fine but what are we going to do with
         * the logic of adding different outgoing edge to different
         * acdg(s)
         */
        /*
         * I'll have to start considering the idea of specifying the order
         * in which the nodes are visited. Suppose if I start visiting the graph
         * nodes not in an undertermined order but rather starting from the end
         * node and then traversing them in a breadth first manner going up to the top then
         * I can use a slightly updated version of my current logic in which whenever
         * I visit a component node I add it to the current configs and instead of
         * adding in the incoming edge, I should add the outgoing edge to the configs
         * 
         */
        updateConfigsDueToXorBranches(n);
    }

    /*
     * (non-Javadoc)
     * 
     * @see cmsc433.p2.ACDGVisitor#isOk()
     */
    public boolean isOk()
    {

        if ( this.configs == null) return false;
        if ( this.configs.isEmpty() == true ) return false;
        return true;
    }

    /*
     * (non-Javadoc)
     * 
     * @see cmsc433.p2.ACDGVisitor#doCheck()
     */
    public void doCheck()
    {

        /* so this method is called by the acdg to generate configs */

        /* now we need to iterate over all the nodes in the acdg and
         * generate all the possible combination of config acdg(s)
         * and after we have generated those we can use the config checker
         * to find which configs fail and remove those from the final config
         * list
         */

        /* the two branching scenarios are the list of versions and the xor nodes */

        /* version branch will be generated by the component nodes and the 
         * the xor branches will be generated by the relation (xor) nodes
         */
        /* so i'm guessing that every config we will generate will contain the same head and tail  */

        /* therefore let's start visiting every node and every time we visit a component node with multiple versions
         * we will add each version to a different ACDG 
         */

        /* i can't figure out how to identify how many configs we should start with or how to create a new config */

        /* okay let's start filling this in, at the very least we know that we have to visit every node, whether or not we have to
         * visit edges separately or if edge should be handled inside the node visit logic could be though upon later
        
         */

        /* do we need to do anything different for the top and bottom nodes or are they to be visited just as the other nodes */
/*        for (MyNode node : this.acdg.getNodeSet())
        {
            node.accept(this);
        }*/

        /* I think I have it, we iterate over the nodes and visit them, if they are branching nodes then they'll generate partial acdg(s),
         * for every new branch we will that that many more new partial acdg(s) to the existing number of configuration
         * also if the current node being visited is not a branching node then we simply add that node to the existing partial configs
         */
        
        /* I have to update the logic in here, I can't traverse the nodes in a random order, I'll have to start
         * with the end node and do a breadth first search.
         */
        LinkedList<MyNode> nodesInBFSOrder = new LinkedList<MyNode>();
        MyNode toStart = this.acdg.getBottom();
        Queue<MyNode> toVisit = new LinkedList<MyNode>();
        toVisit.add(toStart);
        while ( (toVisit != null) && (toVisit.isEmpty() == false ) )
        {
            MyNode nodeToVisit = toVisit.poll();
            nodesInBFSOrder.add(nodeToVisit);
            Set<MyEdge> adjacentEdges = this.acdg.getGraph().getInEdges(nodeToVisit);
            for ( MyEdge edge : adjacentEdges )
            {
                MyNode parent = edge.getParent();
                if (toVisit.contains(parent) == false )
                {
                    toVisit.offer(edge.getParent());
                }
            }
        }
        for ( MyNode node : nodesInBFSOrder )
        {
            node.accept(this);
/*            System.out.println("*****printing snapshot of configs*****");
            for ( ACDG acdg : this.configs )
            {
                System.out.println("nodes: ");
                for ( MyNode n : acdg.getGraph().getNodeSet())
                {
                    System.out.println(n);
                }
                System.out.println("edges: ");
                for ( MyEdge e : acdg.getGraph().getEdgeSet())
                {
                    System.out.println(e.getParent() + "->" + e.getChild());
                }
            }*/
        }
        /*
         * after iterating visiting all nodes we have generated the configs
         * and we need to run them through constraint checker to identify
         * the valid constraints
         */
        /*
         * do I do this progressively while the acdg is being build or after the acdg is built should I try to
         * determine if that acdg violates any constraints
         */
        //list to store the identified valid acdg(s)
        List<ACDG> validACDG = new ArrayList<>();
        for ( ACDG acdg : this.configs )
        {
            ConstraintChecker cChecker = new ConstraintChecker(this.acdg, acdg);
            cChecker.doCheck();
            if ( cChecker.isOk() )
            {
                validACDG.add(acdg);
            }
        }
        this.configs.clear();
        this.configs.addAll(validACDG);
    }

    /**
     * Gets the configuration ACDGs
     * 
     * @return the configs
     */
    public List<ACDG> getConfigs()
    {

        return this.configs;
    }
    
    /* method to update the existing configs and add a new node to them while possibly creating new
     * versions of the configs
     */
    private void updateConfigsDueToComponentVersions(MyNode nodeToAdd)
    {

        if (nodeToAdd == null)
        {
            throw new IllegalArgumentException("null param");
        }
        int numBranches = nodeToAdd.getVersions().size();
        /* function to add nodeToAdd to numBrances number of branches */
        if (this.configs.isEmpty() == true)
        {
            /*if no acdg(s) exist then create a new one with just one node in it*/
            /*this is a special case which will be called only by the head node*/
            /*therefore this should not be called with numBranches more than 1*/
            if (numBranches != 1)
            {
                throw new RuntimeException("Top node can't have more than 1 versions");
            }
            else
            {
                /* create a new MyGraph with nothing but one param node */
                /* the top, bottom, constraints attributes are going to remain the same as the original acdg, the only thing that need to be
                 * different is the graph
                 */
                MyGraph graph = new MyGraph();
                graph.addNode(nodeToAdd.clone());
                ACDG newAcdg = new ACDG(this.acdg.getTop().clone(), this.acdg.getBottom().clone(),
                        this.acdg.getConstraints(), graph);
                this.configs.add(newAcdg);
            }
        }
        else
        {
            /* update the existing configs and maybe create new ones */
            if (numBranches == 1)
            {
                /* add the new node and its outgoing edges to the existing configs */
                for (ACDG acdg : this.configs)
                {
                    acdg.getGraph().addNode(nodeToAdd.clone());
                    for (MyEdge edge : this.acdg.getGraph().getOutEdges(nodeToAdd))
                    {
                        /* can't add the edge object directly, should add a new edge */
                        acdg.getGraph().addEdge(new MyEdge(edge.getParent().clone(), edge.getChild().clone()));
                    }
                }
            }
            else
            {
                /* create new configs based on the number of branches and add this new node to every branch*/

                /* first create the new acdg(s) according to the number of branches that we have to create
                 * and the number of acdg(s) that already exist
                 */
                /** list to contain the new list of acdg(s) */
                List<ACDG> newColl = new ArrayList<>();
                /* update - let's try modifying this loop to generate the new node as well while we are generating the new acdg */
                /* get new list of new versions */
                List<String> newVersionsOfNode = nodeToAdd.getVersions();
                /* for all the branches we have to create */
                for (int i = 0; i < numBranches; i++)
                {
                    /* for all the acdg(s) that already exist */
                    for (ACDG acdg : this.configs)
                    {
                        /* create a new acdg and add it to the new collection */
                        /* create new acdg same as the existing */
                        /* new graph object need to be created and added to this new acdg*/
                        MyGraph newGraph = new MyGraph();
                        /* add node clones to this new graph */
                        for ( MyNode n : acdg.getGraph().getNodeSet() )
                        {
                            newGraph.addNode(n.clone());
                        }
                        /* add edge clones to this new graph */
                        for (MyEdge e : acdg.getGraph().getEdgeSet() )
                        {
                            newGraph.addEdge(new MyEdge(e.getParent(), e.getChild()));
                        }
                        ACDG newAcdg = new ACDG(acdg.getTop().clone(), acdg.getBottom().clone(), acdg.getConstraints(),
                                newGraph);
                        /* create the new node to add */
                        MyNode node = nodeToAdd.clone();
                        /* update the version info according to the branch index we are iterating on */
                        node.removeAllVersions();
                        node.addVersion(newVersionsOfNode.get(i));
                        /* add this new node and its corresponding edges from the original acdg to this new acdg */
                        newAcdg.getGraph().addNode(node);
                        /* add all of the nodeToAdd's edges to this acdg */
                        for (MyEdge edge : this.acdg.getGraph().getOutEdges(nodeToAdd))
                        {
                            newAcdg.getGraph().addEdge(edge);
                        }
                        /* new acdg ready, add it to new collection */
                        newColl.add(newAcdg);
                    }
                }
                /* add these elements of newColl back in configs */
                this.configs.clear();
                this.configs.addAll(newColl);
                /* and we're done */
            }
        }
    }
    
    private void updateConfigsDueToXorBranches(MyNode nodeToAdd)
    {
        /*
         * this should follow similar logic as to the logic for visiting a component node, except that
         * instead of branching due to version, we'll be branching due to multiple outgoing edges
         */
        /*
         * don't have to worry about the generated config list being empty because that should never be the case, it should be caught before this
         * method gets called
         */
        /*
         * if there is just one outgoing edge then add this node too all the current configs
         */
        
        /*
         * if there are multiple outgoing edges then the number of total configs after adding this node should be equal to the current number of
         * acdg in the configs multiplied by the number of outgoing edges of this node, might use logic similar to the one in the component node
         * logic
         */
        int numBranches = this.acdg.getGraph().getOutEdges(nodeToAdd).size();
        /* check to make sure that this node is never visited while the existing list of configs is empty because it is an error condition */
        if ( (this.configs == null ) || (this.configs.isEmpty() == true) )
        {
            throw new Error("Relation XOR node visited before any of the component nodes");
        }
        if ( numBranches == 1 )
        {
            //just add this node and its outoing edge to every existing config
            for ( ACDG acdg : this.configs )
            {
                acdg.getGraph().addNode(nodeToAdd.clone());
                for ( MyEdge edge : this.acdg.getGraph().getOutEdges(nodeToAdd))
                {
                    acdg.getGraph().addEdge(new MyEdge(edge.getParent().clone(), edge.getChild().clone()));
                }
            }
        }
        else
        {
            //new list which will contain the existing and the newly created acdg configs
            List<ACDG> newColl = new ArrayList<>();
            //list containing all the branching variables
            List<MyEdge> xorEdges = new ArrayList<>(this.acdg.getGraph().getOutEdges(nodeToAdd));
            //increase the existing number of configs and add this node and appropriate edge to every config
            for ( int i = 0; i < numBranches; i++ )
            {
                for ( ACDG acdg : this.configs )
                {
                    /* create a new acdg and add it to the new collection */
                    /* create new acdg same as the existing */
                    /* new graph object need to be created and added to this new acdg*/
                    MyGraph newGraph = new MyGraph();
                    /* add node clones to this new graph */
                    for ( MyNode n : acdg.getGraph().getNodeSet() )
                    {
                        newGraph.addNode(n.clone());
                    }
                    /* add edge clones to this new graph */
                    for (MyEdge e : acdg.getGraph().getEdgeSet() )
                    {
                        newGraph.addEdge(new MyEdge(e.getParent(), e.getChild()));
                    }
                    ACDG newAcdg = new ACDG(acdg.getTop().clone(), acdg.getBottom().clone(), acdg.getConstraints(),
                            newGraph);
                    /* create the new node to add */
                    MyNode node = nodeToAdd.clone();
//                    node.addVersion(newVersionsOfNode.get(i));
                    /* add this new node and its corresponding edges from the original acdg to this new acdg */
                    newAcdg.getGraph().addNode(node);
                    /* add one of the nodeToAdd's xor outgoing edge to this acdg */
                    newAcdg.getGraph().addEdge(new MyEdge(xorEdges.get(i).getParent(), xorEdges.get(i).getChild()));
                    /* now that the right edge is added, remove the nodes corresponding to the edges which are not going to be added */
                    List<MyNode> nodesToRemove = this.getNodesToRemove(this.acdg, xorEdges.get(i));
                    for ( MyNode n : nodesToRemove )
                    {
                        newAcdg.getGraph().realGraph.removeVertex(n);
                    }
                    /* new acdg ready, add it to new collection */
                    newColl.add(newAcdg);
                }
            }
            /* add these elements of newColl back in configs */
            this.configs.clear();
            this.configs.addAll(newColl);
            /* and we're done */
        }
    }
    
    private List<MyNode> getNodesToRemove(ACDG acdg, MyEdge edge)
    {
        /*
         * the edge will provide us with the parent node, we have to retrieve all the edges of that parent node and all the nodes other than
         * this node will provide us with the nodes to return
         */
        MyNode parent = edge.getParent();
        Set<MyEdge> otherEdges = new HashSet<>(acdg.getGraph().getOutEdges(parent));
        otherEdges.remove(edge);
        List<MyNode> toRemove = new ArrayList<MyNode>(otherEdges.size());
        for ( MyEdge e : otherEdges )
        {
            toRemove.add(e.getChild());
        }
        return toRemove;
    }
}